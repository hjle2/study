# Spring API JSON 공부하기

## 톰캣 구동,(web.xml)
스프링 프로젝트를 구동하면 WAS가 먼저 구동되고, WAS의 서블릿 컨테이너인 Web.xml이 구동 된다.

## Context Path 설정하기
톰캣의 server.xml 파일을 보면 path에 접속 경로를 매핑시킬 수 있다.

## 루트 컨테이너 생성
구동될 때 참조하는 설정 파일은 프로젝트 내부의 "WEB-INF/web.xml"파일.
루트 컨테이너는 어플리케니션(프로젝트 단위)에 딱 하나 생기는 최상위 부모 컨테이너
스프링 컨테이너는 루트 컨테이너가 하나, 각 서블릿이 하나씩 가지는 컨테이너, 그리고 개발자가 직접 생성하는 컨테이너까지 3 가지의 종류가 있다.

루트 컨테이너에서는 웹기술과 관계 없는 자원에 대한 빈을 만들어 관리한다.
디폴트로는 "root-context.xml"파일을 param으로 제공해주지만 필요 시 새로운 파일을 만들어 param으로 추가할 수 있다.
어플리케이션 컨텍스트 라고도 부른다.

루트와 서블릿용 컨테이너는 스프링 구조에 따라 설정 파일에 있는 내용대로 자동으로 생성된다.
개발자가 관여하는 부분은 없다.
루트 컨테이너에서 모든 서블릿들에게 공유할 전역 설정과 빈을 생성해 사용한다.
서블릿용 컨테이너에서는 해당 서블릿 고유 설정과 빈을 생성해 사용한다.
서블릿용 컨테이너는 루트 컨테이너의 자식이며, 부모 컨테이너로부터 필요한 것을 가져와 사용할 수 있지만, 그 반대는 불가능 하다.

## URL 매핑
WAS가 클라이언트로부터 URL 요청을 받았을 때 어떤 서블릿 클래스로 넘겨줄지 매핑해주는 설정이다.
원래 개발자가 직접 서블릿을 만들었었지만, 스프링에서는 "DispatcherServelet"클래스를 제공해준다.
param을 통해 서블릿 생성시 서블릿 컨테이너의 설정 파일을 설정할 수 있다.

## 필터 설정 적용
필터 설정은 서블릿으로 요청(클라이언트의 URL 요청)이 들어가기 전, 그리고 최종 응답 전에 공통적으로 수행되어야 할 기능을 구현해주는 설정.
가장 필수적이면서 많이 쓰는 용도가 인코딩 이다.
필터 설정 덕분에 기존 섯블릿에서 일일이 요청객체마다 처리해주던 인코딩을 별도로 할 필요가 없다.
그 외에 스프링 시큐리티 등 여러 공통 처리에 대한 필터 설정 가능.

## 클라이언트 요청에 따른 서블릿 구동
서블릿 컨테이너(WAS)가 구동되면, 웹 어플리케이션은 클라이언트 요청을 기다리고 있는 상태가 된다.

## DispatcherServlet 로드 및 스프링 컨테이너 생성
첫 요청이 들어오면, 서블릿 컨테이너가 URL이 매핑된 서블릿을 찾아 메모리에 로드 시킵니다.
스프링 MVC 프로젝트에서는 프론트 컨트롤러의 서블릿 역할로 이미 스프링에서 만들어둔 "DispatcherServlet"클래스를 사용하게 된다.

처음 서블릿 구동시 초기화 파라미터로 "sevlet-context.xml"파일을 넘겨주고, 서블릿은 이 설정대로 동작한다.
필요시 xml파일을 추가하여 param으로 추가할 수 있다.
서블릿용 컨테이너를 생성해 서블릿 구동에 필요한 핸들러, 컨트롤러 등의 빈 객체를 갖는다.

## servlet-context.xml의 설정대로 기능 분배
이제 요청을 처리할 구동 절차가 완료된다.
서블릿으로 들어온 요청을 매핑된 컨트롤러 클래스를 찾아 요청을 넘겨주는 설정을 통해 적절히 분배해주면 된다.
@Controller, @RestMapping 등의 어노테이션을 찾아 처리해준다.
"component-scan"은 어노테이션을 스캔할 패키지의 범위 이다.
만약, 컨트롤러 클래스가 다른 패키지에도 있다면 해당 패키지를 추가하도록 설정하여 찾을 수 있도록 해준다.

### context라는 전용 태그를 통해 어노테이션을 스캔해서 빈으로 만들어주는 기능을 하는 여러 클래스들의 빈과, 설정들을 자동으로 세팅해준다.
전용태그 없이 bean 설정만으로도 가능하지만 설정이 복잡하기 때문에 전용 태그를 사용하는 것이 좋다.
css, js, 이미지 등의 정적 리소스는 컨트롤러를 통해 분배하지 않고 클라이언트가 직접 접속해서 가져가도록 한다.
기본 제공되는 "/resourse"폴더에 있지 않으면 따로 설정해ㅑㅇ 한다.
참고로 "WEB-INF" 폴더는 외부에서 직접 접속 불가능한 폴더이기 때문에 정적 리소스를 위치시키면 안된다.


### 컨트롤러 클래스의 처리기 메소드가 요청을 처리한 뒤에는 뷰 이름을 String 타입으로 리턴하면, 리턴된 뷰 페이지 이름은 다시 서블릿이 받아 처리한다.
이 부분을 담당하는 객체가 "ViewResolver"이다.
설정 파일에 빈 객체를 등록하도록 되어 있지만, 다른 핸들러처럼 알아서 처리하지 않고 설정을 따로 넣어주어야 한다.
개발자가 초기화 파라미터를 제공해야 한다.

기본 설정으로 뷰 페이지 이름이 들어오면 "prefix + 리턴된 문자열 + .jsp" 로 만들어 사용하도록 초기화 파라미터에 prefix 와 suffix 를 설정할 수 있다.

서블릿/jsp 구조와 마찬가지로 한 번 응담하면 컴파일된 뷰 페이지의 코드는 계속 메모리에 로드된 상태로 재활용 한다.

## 개발자가 짠 로직 전개
서블릿 구동까지 끝난 후 개발자가 짜둔 코드에 접근해 로직을 전개한다.

## 서블릿 컨테이너가 요청을 처리할 스레드 생성
서블릿은 멀티 스레드 환경으로 구동되기 때문에, WAS가 기동될 때 스레드풀을 생성하고, 알아서 처리해준다.

위의 과정들에서 서블릿이 구동되며 생겨난 컨테이너와 객체들은 모두 싱글톤 패턴으로, 모든 스레드에서 공유할 수 있는 객체들이다.
따라서 지금 생성된 스레드는 개발자가 객체를 새로 생성하지 않는 이상 별도의 객체를 갖고 있지 않은 상태이다.
따라서, 컨트롤러 클래스의 처리기 메소드 코드 또한, 객체를 생성하는게 아니라 기존 객체를 참조해 사용하게 된다.

## 메소드 안의 개발자용 컨테이너 생성 및 빈 객체 사용
메소드 안에서 개발자용 컨테이너를 생성할 경우, 일반 변수와 마찬가지로 스택 프레임 내의 지역변수로 생성된다.
즉, 컨테이너의 최대 생존 시간은 스레드의 생존 시간과 같다. 컨테이너 또한 하나의 객체이다.
실제 컨테이너와 빈 객체는 힙 메모리에 저장되지만, 스택 프레임 안의 참조를 잃는 순간 GC 의 대상이 되기 때문에 close메소드를 통해 직접 컨테이너 자원 해제를 해야 한다.

## 컨트롤러 클래스의 필드멤버로 개발자용 컨테이너 생성 및 빈 객체 사용
위의 문제를 해결하기 위한 방법으로, 컨트롤러 클래스는 서블릿용 컨테이너에서 참조하는 빈 객체가 되어 어플리케이션의 종료까지 GC 대상이 되지 않는다.
따라서 필드 멤버로 컨트롤러 클래스를 컨테이너로 만들 경우, 이 컨테이너 또한 별도로 close()를 해줄 떄까지 참조를 잃지 않는다.

컨테이너와 빈에 대한 활용은 대부분 @Component 계열의 어노테이션을 통해 루트 컨테이너에 등록해 사용하는 경우가 많다.


